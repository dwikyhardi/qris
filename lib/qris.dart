/// A library to help with interpreting and processing the contents of QRIS
/// (QR Indonesian Standard) code which is widely distributed as a standardized
/// payment medium which integrates with various Payment Systems, mostly mobile
/// banking apps and popular Electronic Money providers that enable QR Code
/// scanning.
library qris;

/// Creates an object that holds various information of a QRIS (QR Indonesian
/// Standard) Code.
///
/// Default implementation requires a [String] containing a well-formatted QR
/// text data according to ISO/IEC 18004, which is usually obtainable after
/// scanning a physically printed QR Codes, or the one generated dynamically
/// from certain merchant digital devices.
class QRIS {

  QRIS._(this._data,);

  /// Generates a QRIS instance with parsed information, given a [data] String.
  ///
  /// Throws a [QRISError] if the provided data is not a valid String that
  /// conforms to QRIS standard.
  QRIS(String data,): _data = _fillData(
    data, (position,) => QRISError._(position,),
  ) {
    _rawQrData = data;
    for (int i = 2; i <= 50; i++) {
      final key = i.toString().padLeft(2, '0',);
      final merchantData = _data[key];
      if (merchantData != null) {
        _merchants[key] = QRISMerchantAccountInformation._(merchantData,);
      }
    }
    final additionalData = _data["62"];
    if (additionalData is String) {
      _additionalDataField = QRISAdditionalData._(additionalData,);
    }
  }

  /// Creates a copy of existing QRIS instance with overridden properties.
  ///
  /// A typical use case such as adding a transaction amount to a physically
  /// scanned QRIS Code.
  ///
  /// Accepts a [transactionAmount] currently.
  QRIS copyWith({num? transactionAmount,}) {
    final Map<String, String?> dataCopy = Map.from(_data,);
    dataCopy["54"] = transactionAmount?.toString() ?? _data["54"];
    return QRIS._(dataCopy,);
  }

  late final String _rawQrData;

  final Map<String, String?> _data;

  static Map<String, String> _fillData(String qris, Error Function(int position,) onError,) {
    int i = 0;
    try {
      final Map<String, String> components = {};
      while (i < qris.length) {
        final rootId = "${qris[i]}${qris[i + 1]}";
        final length = int.tryParse("${qris[i + 2]}${qris[i + 3]}",) ?? 0;
        components[rootId] = qris.substring(i + 4, i + 4 + length,);
        i += 4 + length;
      }
      return Map.unmodifiable(components,);
    } catch (_) {
      throw onError(i,);
    }
  }

  /// The Payload Format Indicator, indicates the version of the QRIS Code.
  ///
  /// A valid QRIS Code must have this field.
  int get payloadFormatIndicator => int.parse(_data["00"] ?? "",);

  /// The Point of Initiation Method code. Indicates the origin of the QRIS Code.
  ///
  /// 11 indicates a static QRIS Code, usually the physically printed ones.
  /// 12 indicates a dynamically generated QRIS Code, usually generated by the
  /// merchant.
  QRISInitiationPoint? get pointOfInitiation {
    final data = _data["01"];
    switch (data) {
      case "11": return QRISInitiationPoint.staticCode;
      case "12": return QRISInitiationPoint.dynamicCode;
    }
  }

  final Map<String, QRISMerchantAccountInformation> _merchants = {};

  /// All available merchants listed on this QRIS Code
  List<QRISMerchantAccountInformation> get merchants => _merchants.values.toList(
    growable: false,
  );
  List<QRISMerchantAccountInformation> _getMerchantsByRange(int start, int end,) {
    final merchants = <QRISMerchantAccountInformation>[];
    for (int i = start; i <= end; i++) {
      final key = i.toString().padLeft(2, '0',);
      final merchant = _merchants[key];
      if (merchant != null) {
        merchants.add(merchant,);
      }
    }
    return List.unmodifiable(merchants,);
  }

  /// VISA Merchants (ID "02" and "03")
  List<QRISMerchantAccountInformation> get visaMerchants => _getMerchantsByRange(2, 3,);
  /// MasterCard Merchants (ID "04" and "05)
  List<QRISMerchantAccountInformation> get mastercardMerchants => _getMerchantsByRange(4, 5,);
  /// EMVCo Merchants (ID "06" - "08")
  List<QRISMerchantAccountInformation> get emvCoMerchants => _getMerchantsByRange(6, 8,);
  /// Discover Credit Card Merchants (ID "09" and "10")
  List<QRISMerchantAccountInformation> get discoverMerchants => _getMerchantsByRange(9, 10,);
  /// AMEX (American Express) Merchants (ID "11" and "12")
  List<QRISMerchantAccountInformation> get amExMerchants => _getMerchantsByRange(11, 12,);
  /// JCB (Japan Credit Bureau) Merchants (ID "13" and "14")
  List<QRISMerchantAccountInformation> get jcbMerchants => _getMerchantsByRange(13, 14,);
  /// Union Pay Merchants (ID "15" and "16")
  List<QRISMerchantAccountInformation> get unionPayMerchants => _getMerchantsByRange(15, 16,);
  /// EMVCo Merchants (ID "17" - "25")
  List<QRISMerchantAccountInformation> get emvCoMerchants2 => _getMerchantsByRange(17, 25,);
  /// Domestic Merchants, most common QRIS Codes are used by domestic merchants (ID "26" - "45")
  List<QRISMerchantAccountInformation> get domesticMerchants => _getMerchantsByRange(26, 45,);
  /// Additional Domestic Merchants information as reserve list, usually empty (ID "46" - "50")
  List<QRISMerchantAccountInformation> get reservedDomesticMerchants => _getMerchantsByRange(46, 50,);

  /// Merchant Account Information Domestic Central Repository
  ///
  /// If [merchants] is empty, then most likely there's a single Merchant Account
  /// available at ID "51". (No merchant information between ID "02" to "45")
  QRISMerchantAccountDomestic? get merchantAccountDomestic {
    final data = _data["51"];
    if (data != null) {
      return QRISMerchantAccountDomestic._(data,);
    }
  }

  /// Merchant Category Code (MCC in short)
  ///
  /// Code references are available at [https://github.com/greggles/mcc-codes/](https://github.com/greggles/mcc-codes/)
  int? get merchantCategoryCode => int.tryParse(_data["52"] ?? "",);

  /// The Transaction Currency, conforms to ISO 4217, represented as 3 digits Numeric.
  ///
  /// Should default to constant **"360"** to represent IDR currency (Indonesian).
  /// Reference: [https://en.wikipedia.org/wiki/ISO_4217](https://en.wikipedia.org/wiki/ISO_4217)
  String? get transactionCurrency => _data["53"];

  num? _userInputTransactionAmount;

  /// The transaction amount contained within this QRIS, or the one entered manually
  /// through [transactionAmount]'s setter, if any.
  num? get transactionAmount => _userInputTransactionAmount ?? originalTransactionAmount;

  /// The original transaction amount available within this QRIS, fetched from
  /// the raw data, if available.
  num? get originalTransactionAmount => num.tryParse(_data["54"] ?? "",);
  set transactionAmount(num? amount,) => _userInputTransactionAmount = amount;

  /// The [TipIndicator] of the QRIS Code.
  ///
  /// Indicates the origin of the provided Tip to the merchant, if available.
  TipIndicator? get tipIndicator {
    final data = _data["55"];
    switch (data) {
      case "01": return TipIndicator.mobileAppRequiresConfirmation;
      case "02": return TipIndicator.tipValueFixed;
      case "03": return TipIndicator.tipValuePercentage;
    }
    return null;
  }

  /// This should be a non-null value if [tipIndicator] is [TipIndicator.tipValueFixed]
  num? get tipValueOfFixed {
    final data = _data["56"];
    if (data != null) {
      return num.tryParse(data,);
    }
  }

  /// This should be a non-null value if [tipIndicator] is [TipIndicator.tipValuePercentage]
  ///
  /// Expected range is 00.01 to 99.99 (in percentage)
  double? get tipValueOfPercentage {
    final data = _data["57"];
    if (data != null) {
      return double.tryParse(data,);
    }
  }

  /// The country code of the merchant, conforming to ISO 3166-1's Alpha 2 Code.
  ///
  /// Should default to "ID", if available.
  String? get countryCode => _data["58"];

  /// Name of the merchant, usually presented in UPPER-CASED String.
  String? get merchantName => _data["59"];

  /// City name of where the merchant is located, usually presented in UPPER-CASED
  /// String.
  String? get merchantCity => _data["60"];

  /// The postal code that corresponds to merchant's location.
  ///
  /// A non-null value is expected for [countryCode] equals to **"ID"**.
  String? get postalCode => _data["61"];

  QRISAdditionalData? _additionalDataField;
  /// Additional data that complements the QRIS data with more technical details.
  QRISAdditionalData? get additionalDataField => _additionalDataField;

  /// The additional information about the merchant, represented in a preferred
  /// language preference.
  QRISMerchantInformationLocalized? get merchantInformationLocalized {
    final data = _data["64"];
    if (data is String) {
      return QRISMerchantInformationLocalized._(data,);
    }
  }

  /// The CRC Checksum of the QRIS Code contents as [int].
  int? get crc {
    final crc = _data["63"];
    if (crc != null) {
      return int.tryParse(crc, radix: 16,);
    }
  }

  /// The CRC Checksum of the QRIS Code contents as Hex String
  String? get crcHex => _data["63"];

  List<String> get emvCo {
    return List.generate(
      15, (index) => index + 65,
    ).map(
      (e) => e.toString(),
    ).map(
      (e) => _data[e],
    ).whereType<String>().toList();
  }

  /// The raw QRIS data stored as a plain [Map] of Strings.
  Map<String, String> get rawMapData => Map.unmodifiable(_data,);

  /// Print the QRIS contents using the [MapEntry] approach.
  void printByEntries() {
    // ignore: avoid_print
    print(
      _data.entries.map(
        (e) => "${e.key}: ${e.value}",
      ).join("\n",),
    );
  }

  /// The raw [String] of the scanned QRIS Code.
  @override
  String toString() {
    return _rawQrData;
  }
}

/// The description of the origin of the QRIS Code
enum QRISInitiationPoint {
  /// The QRIS is static, usually printed physically around the merchant's
  /// vicinity.
  staticCode,
  /// The QRIS is dynamically generated, usually through smartphones/EDC devices
  /// from the merchant.
  dynamicCode,
}

/// Represents the Transaction/Payment Method using this QRIS Code
enum PANMerchantMethod {
  unspecified,
  /// Debit Cards
  debit,
  /// Credit Cards
  credit,
  /// Common/Popular Electronic Money Providers, e.g: GoPay, OVO, DANA, etc
  electronicMoney,
  /// Reserved for Future Use
  rfu,
}

/// Tip Indicator indicates how the Tip to the merchant should be calculated/provided.
enum TipIndicator {
  /// The mobile app should ask for consumer's confirmation to provide the tip amount.
  mobileAppRequiresConfirmation,
  /// The tip value must be a fixed numeric amount.
  tipValueFixed,
  /// The tip value must be calculated as percentage amount between 00.01 - 99.99%.
  tipValuePercentage,
}

/// The information of a Merchant Account
///
/// Plain merchants usually only have a single Merchant Account embedded in the
/// QRIS code.
///
/// Throws [QRISMerchantError] on invalid Merchant data.
class QRISMerchantAccountInformation {

  QRISMerchantAccountInformation._(String data,): _data = QRIS._fillData(
    data, (position) => QRISMerchantError._(position,),
  );

  final Map<String, String> _data;

  /// Merchant identifier in the form of reverse domain name. Usually presented
  /// in UPPER-CASED.
  ///
  /// e.g: COM.EXAMPLE.DEMO
  String? get globallyUniqueIdentifier => _data["00"];

  /// Personal Account Number (PAN)
  String? get panCode => _data["01"];

  /// National Numbering System (NNS), which is the first 8 digits of PAN
  String? get nationalNumberingSystemDigits {
    final panCode = this.panCode;
    if (panCode != null) {
      if (panCode.length >= 8) {
        return panCode.substring(0, 8,);
      }
    }
  }

  /// The main transaction/payment method.
  PANMerchantMethod get panMerchantMethod {
    final panCode = this.panCode;
    if (panCode != null) {
      if (panCode.length >= 9) {
        final indicator = panCode[8];
        switch (indicator) {
          case "0": return PANMerchantMethod.unspecified;
          case "1": return PANMerchantMethod.debit;
          case "2": return PANMerchantMethod.credit;
          case "3": return PANMerchantMethod.electronicMoney;
          default:
            final indicatorValue = int.tryParse(indicator,);
            if (indicatorValue != null) {
              if (indicatorValue >= 4 && indicatorValue <= 9) {
                return PANMerchantMethod.rfu;
              }
            }
            return PANMerchantMethod.unspecified;
        }
      }
    }
    return PANMerchantMethod.unspecified;
  }

  /// Merchant ID, with length up to 15 characters
  String? get id => _data["02"];

  /// Merchant Criteria which describes the size/scale of the merchant
  QRISMerchantCriteria get merchantCriteria {
    final data = _data["03"];
    switch (data) {
      case "UMI": return QRISMerchantCriteria.micro;
      case "UKE": return QRISMerchantCriteria.small;
      case "UME": return QRISMerchantCriteria.medium;
      case "UBE": return QRISMerchantCriteria.large;
    }
    return QRISMerchantCriteria.regular;
  }
}

/// Indicator of the merchant's size/scale.
///
/// Excluding the asset values of occupied land for business and infrastructures.
/// Number figures are represented in IDR.
enum QRISMerchantCriteria {
  /// The smallest merchant size with average net profit up to 50 millions and
  /// sales average up to 300 millions.
  micro,
  /// The small merchant size above [QRISMerchantCriteria.micro] with net profit
  /// up to 500 millions and sales average up to 2.5 billions.
  small,
  /// The medium size specifies a net profit range between 500 millions, up to
  /// 10 billions, with sales average up to 50 billions.
  medium,
  /// Number figures are higher than [QRISMerchantCriteria.medium].
  large,
  /// No clear specifications
  regular,
}

/// Representation of Unique, Single Merchant Account Information specifically
/// for Domestic Transactions.
///
/// Shares the same signature as [QRISMerchantAccountInformation], excluding
/// the [QRISMerchantAccountInformation.panCode] data.
///
/// This data is expected to be provided, given that no Merchant information
/// exists between ID "02" to "45".
class QRISMerchantAccountDomestic {

  QRISMerchantAccountDomestic._(String data,): _data = QRIS._fillData(
    data, (position) => QRISMerchantError._(position,),
  );

  final Map<String, String> _data;

  /// See [QRISMerchantAccountInformation.globallyUniqueIdentifier]
  String? get globallyUniqueIdentifier => _data["00"];

  /// See [QRISMerchantAccountInformation.id]
  String? get merchantID => _data["02"];

  /// See [QRISMerchantAccountInformation.merchantCriteria]
  QRISMerchantCriteria get merchantCriteria {
    final data = _data["03"];
    switch (data) {
      case "UMI": return QRISMerchantCriteria.micro;
      case "UKE": return QRISMerchantCriteria.small;
      case "UME": return QRISMerchantCriteria.medium;
      case "UBE": return QRISMerchantCriteria.large;
    }
    return QRISMerchantCriteria.regular;
  }
}

/// Additional data that supports the current QRIS transaction with more
/// technical details.
///
/// Generation of this data may throw [QRISAdditionalDataError].
class QRISAdditionalData {

  QRISAdditionalData._(String data,): _data = QRIS._fillData(
    data, (position) => QRISAdditionalDataError._(position,),
  );

  QRISAdditionalData._copy(this._data,);

  /// Creates a copy of [QRISAdditionalData] with overridden properties.
  QRISAdditionalData copyWith({
    String? billNumber,
    String? mobileNumber,
    String? storeLabel,
    String? loyaltyNumber,
    String? referenceLabel,
    String? customerLabel,
    String? terminalLabel,
    String? purposeOfTransaction,
  }) {
    final Map<String, String?> dataCopy = Map.from(_data,);
    void filter(String key, String? newValue,) {
      if (newValue != null) {
        if (newValue.length >= 3) {
          dataCopy[key] = newValue.substring(0, 3,);
          return;
        }
      }
      dataCopy[key] = _data[key];
    }
    filter("01", billNumber,);
    filter("02", mobileNumber,);
    filter("03", storeLabel,);
    filter("04", loyaltyNumber,);
    filter("05", referenceLabel,);
    filter("06", customerLabel,);
    filter("07", terminalLabel,);
    filter("08", purposeOfTransaction,);
    return QRISAdditionalData._copy(dataCopy,);
  }

  final Map<String, String?> _data;

  /// Bill Number or Invoice Number.
  ///
  /// Indicates that the mobile app should ask the consumer for a Bill Number,
  /// such as for Utility Payments.
  String? get billNumber => _data["01"];

  /// The mobile number that interacts with this transaction.
  ///
  /// Indicates that the consumer should provide a mobile number, especially for
  /// transactions like Phone Utility Payment or Phone Credit Charging.
  String? get mobileNumber => _data["02"];

  /// Information related to the store's label.
  ///
  /// Indicates that the mobile app should ask the consumer for the store's
  /// label. For example, the store's label will be shown for ease of specific
  /// store identification.
  String? get storeLabel => _data["03"];

  /// Loyalty card number, if available.
  ///
  /// Indicates that the mobile app should ask the consumer to provide the
  /// loyalty card number, if available.
  String? get loyaltyNumber => _data["04"];

  /// Merchant/Acquirer defined value for transaction identification.
  ///
  /// Typically used in transaction log or receipts.
  String? get referenceLabel => _data["05"];

  /// Identifier for a customer.
  ///
  /// Usually depicted as unique Customer IDs, such as Subscription Number,
  /// Student Registration Number, etc.
  String? get customerLabel => _data["06"];

  /// Value related to the payment terminal of a merchant.
  ///
  /// Can be used to identify a distinct payment terminal within many choices at
  /// a merchant.
  String? get terminalLabel => _data["07"];

  /// Describes the purpose of the transaction.
  String? get purposeOfTransaction => _data["08"];

  /// Additional information to assist with the transaction completion.
  ///
  /// Example use case, such as providing a flag indicating that the user has to
  /// provide the mobile number of current payment device, and if necessary,
  /// provides it automatically for convenience.
  QRISAdditionalConsumerDataRequest? get additionalConsumerDataRequest {
    final data = _data["09"];
    if (data is String) {
      return QRISAdditionalConsumerDataRequest._(data,);
    }
  }

  /// Acquirer's use
  QRISProprietaryData? get proprietaryData {
    final data = _data["99"];
    if (data != null) {
      return QRISProprietaryData._(data,);
    }
  }
}

/// The additional consumer data request contained within [QRISAdditionalData].
///
/// The information is obtained within ID "09", if available. Expected a [String]
/// that contains letter A, M, or E, where each letter represents a requirement
/// for a certain information from the consumer.
/// - **A** stands for Address Requirement
/// - **M** stands for Phone Requirement
/// - **E** stands for Email Requirement
class QRISAdditionalConsumerDataRequest {

  QRISAdditionalConsumerDataRequest._(String data,) {
    for (int i = 0; i < data.length; i++) {
      _data[data[i]] = true;
    }
  }

  final Map<String, bool> _data = {};

  bool get consumerAddressRequired => _data["A"] == true;

  bool get consumerPhoneRequired => _data["M"] == true;

  bool get consumerEmailRequired => _data["E"] == true;
}

/// Additional information for Acquirer's purposes.
///
/// Throws [QRISAdditionalDataError] on invalid format.
class QRISProprietaryData {

  QRISProprietaryData._(String data,): _data = QRIS._fillData(
    data, (position) => QRISAdditionalDataError._(position,),
  );

  final Map<String, String> _data;

  /// Unique Identifier for this Proprietary Data. Mostly defaults to "00".
  ///
  /// Max length of 32 characters.
  String? get globallyUniqueIdentifier => _data["00"];

  /// The proprietary data content.
  ///
  /// Max length of 81 characters.
  String? get proprietary => _data["01"];
}

///
/// Information of the Main Merchant, presented in a preferred language setting.
///
class QRISMerchantInformationLocalized {

  QRISMerchantInformationLocalized._(String data,): _data = QRIS._fillData(
    data, (position) => QRISLocalizationError._(position,),
  );

  final Map<String, String> _data;

  /// The preferred language, presented in ISO 639 standard (two letters alphabet).
  String? get languagePreference => _data["00"];

  /// The merchant name, localized by [languagePreference]
  String? get merchantName => _data["01"];

  /// The city of the merchant location, localized by [languagePreference]
  String? get merchantCity => _data["02"];
}

class _QRISError extends Error {

  _QRISError(this.position,);

  final int position;
}

class QRISError extends _QRISError {

  QRISError._(int position): super(position,);

  @override
  String toString() => "Invalid QRIS String data at position $position";
}

class QRISMerchantError extends _QRISError {

  QRISMerchantError._(int position): super(position,);

  @override
  String toString() => "Invalid Merchant data at position $position";
}

class QRISAdditionalDataError extends _QRISError {

  QRISAdditionalDataError._(int position): super(position,);

  @override
  String toString() => "Invalid Additional Data Field Template at position $position";
}

class QRISLocalizationError extends _QRISError {

  QRISLocalizationError._(int position): super(position,);

  @override
  String toString() => "Invalid Localized Merchant Info at position $position";
}